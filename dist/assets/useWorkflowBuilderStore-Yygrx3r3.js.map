{"version":3,"file":"useWorkflowBuilderStore-Yygrx3r3.js","sources":["../../src/stores/useWorkflowBuilderStore.ts"],"sourcesContent":["/**\n * Workflow Builder Store\n * Zustand store for managing workflow builder state\n */\n\nimport { create } from \"zustand\";\nimport { toast } from \"sonner\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport type {\n  Workflow,\n  WorkflowNode,\n  WorkflowEdge,\n  WorkflowNodeType,\n  WorkflowCategory,\n  WorkflowViewport,\n  WorkflowNodeTemplate,\n} from \"@/types/workflow\";\n\ninterface WorkflowBuilderStore {\n  // State\n  workflow: Workflow | null;\n  selectedNodeId: string | null;\n  selectedEdgeId: string | null;\n  isDragging: boolean;\n  isConnecting: boolean;\n  connectionStart: string | null;\n  history: Workflow[];\n  historyIndex: number;\n  isSaving: boolean;\n  isExecuting: boolean;\n  nodeTemplates: WorkflowNodeTemplate[];\n\n  // Actions\n  setWorkflow: (workflow: Workflow) => void;\n  loadWorkflow: (workflowId: string) => Promise<void>;\n  loadUserWorkflows: () => Promise<Workflow[]>;\n  loadNodeTemplates: () => Promise<void>;\n  createNewWorkflow: (name: string, category?: WorkflowCategory) => void;\n\n  // Node operations\n  selectNode: (nodeId: string | null) => void;\n  addNode: (\n    type: WorkflowNodeType,\n    subtype: string,\n    position: { x: number; y: number },\n    config?: Record<string, any>\n  ) => void;\n  updateNode: (nodeId: string, updates: Partial<WorkflowNode>) => void;\n  removeNode: (nodeId: string) => void;\n  duplicateNode: (nodeId: string) => void;\n\n  // Edge operations\n  selectEdge: (edgeId: string | null) => void;\n  addEdge: (source: string, target: string, sourceHandle?: string, label?: string) => void;\n  updateEdge: (edgeId: string, updates: Partial<WorkflowEdge>) => void;\n  removeEdge: (edgeId: string) => void;\n\n  // Connection handling\n  startConnection: (nodeId: string) => void;\n  completeConnection: (nodeId: string) => void;\n  cancelConnection: () => void;\n\n  // Viewport\n  updateViewport: (viewport: Partial<WorkflowViewport>) => void;\n\n  // Drag state\n  setIsDragging: (isDragging: boolean) => void;\n\n  // History\n  undo: () => void;\n  redo: () => void;\n  canUndo: () => boolean;\n  canRedo: () => boolean;\n  pushToHistory: () => void;\n\n  // Persistence\n  saveWorkflow: () => Promise<void>;\n  publishWorkflow: () => Promise<void>;\n  activateWorkflow: (active: boolean) => Promise<void>;\n\n  // Execution\n  executeWorkflow: (triggerData?: Record<string, any>) => Promise<string>;\n\n  // Metadata\n  updateWorkflowMeta: (meta: Partial<Workflow>) => void;\n\n  // Reset\n  resetBuilder: () => void;\n}\n\nconst generateId = () => crypto.randomUUID();\n\nconst createDefaultWorkflow = (\n  userId: string,\n  name: string,\n  category: WorkflowCategory = \"general\"\n): Workflow => ({\n  id: generateId(),\n  userId,\n  name,\n  description: \"\",\n  category,\n  nodes: [],\n  edges: [],\n  viewport: { x: 0, y: 0, zoom: 1 },\n  isPublished: false,\n  isActive: false,\n  version: 1,\n  executionCount: 0,\n  successCount: 0,\n  failureCount: 0,\n  tags: [],\n  createdAt: new Date().toISOString(),\n  updatedAt: new Date().toISOString(),\n});\n\nexport const useWorkflowBuilderStore = create<WorkflowBuilderStore>((set, get) => ({\n  // Initial state\n  workflow: null,\n  selectedNodeId: null,\n  selectedEdgeId: null,\n  isDragging: false,\n  isConnecting: false,\n  connectionStart: null,\n  history: [],\n  historyIndex: -1,\n  isSaving: false,\n  isExecuting: false,\n  nodeTemplates: [],\n\n  // Set workflow\n  setWorkflow: (workflow) => {\n    set({\n      workflow,\n      history: [workflow],\n      historyIndex: 0,\n      selectedNodeId: null,\n      selectedEdgeId: null,\n    });\n  },\n\n  // Load workflow from database\n  loadWorkflow: async (workflowId) => {\n    try {\n      const { data, error } = await supabase\n        .from(\"workflows\")\n        .select(\"*\")\n        .eq(\"id\", workflowId)\n        .single();\n\n      if (error) throw error;\n      if (!data) throw new Error(\"Workflow not found\");\n\n      const workflow: Workflow = {\n        id: data.id,\n        userId: data.user_id,\n        name: data.name,\n        description: data.description || \"\",\n        category: data.category as WorkflowCategory,\n        nodes: (data.nodes as WorkflowNode[]) || [],\n        edges: (data.edges as WorkflowEdge[]) || [],\n        viewport: (data.viewport as WorkflowViewport) || { x: 0, y: 0, zoom: 1 },\n        isPublished: data.is_published,\n        isActive: data.is_active,\n        triggerConfig: data.trigger_config,\n        version: data.version,\n        executionCount: data.execution_count,\n        successCount: data.success_count,\n        failureCount: data.failure_count,\n        lastExecutedAt: data.last_executed_at,\n        tags: data.tags || [],\n        createdAt: data.created_at,\n        updatedAt: data.updated_at,\n      };\n\n      get().setWorkflow(workflow);\n    } catch (error) {\n      console.error(\"Failed to load workflow:\", error);\n      toast.error(\"Failed to load workflow\");\n      throw error;\n    }\n  },\n\n  // Load all user workflows\n  loadUserWorkflows: async () => {\n    try {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) throw new Error(\"Not authenticated\");\n\n      const { data, error } = await supabase\n        .from(\"workflows\")\n        .select(\"*\")\n        .eq(\"user_id\", user.id)\n        .order(\"updated_at\", { ascending: false });\n\n      if (error) throw error;\n\n      return (data || []).map((d) => ({\n        id: d.id,\n        userId: d.user_id,\n        name: d.name,\n        description: d.description || \"\",\n        category: d.category as WorkflowCategory,\n        nodes: (d.nodes as WorkflowNode[]) || [],\n        edges: (d.edges as WorkflowEdge[]) || [],\n        viewport: (d.viewport as WorkflowViewport) || { x: 0, y: 0, zoom: 1 },\n        isPublished: d.is_published,\n        isActive: d.is_active,\n        triggerConfig: d.trigger_config,\n        version: d.version,\n        executionCount: d.execution_count,\n        successCount: d.success_count,\n        failureCount: d.failure_count,\n        lastExecutedAt: d.last_executed_at,\n        tags: d.tags || [],\n        createdAt: d.created_at,\n        updatedAt: d.updated_at,\n      }));\n    } catch (error) {\n      console.error(\"Failed to load workflows:\", error);\n      return [];\n    }\n  },\n\n  // Load node templates\n  loadNodeTemplates: async () => {\n    try {\n      const { data, error } = await supabase\n        .from(\"workflow_node_templates\")\n        .select(\"*\")\n        .eq(\"is_active\", true)\n        .order(\"category\");\n\n      if (error) throw error;\n\n      const templates: WorkflowNodeTemplate[] = (data || []).map((d) => ({\n        id: d.id,\n        type: d.type as WorkflowNodeType,\n        subtype: d.subtype,\n        name: d.name,\n        description: d.description,\n        icon: d.icon,\n        category: d.category,\n        configSchema: d.config_schema || {},\n        defaultConfig: d.default_config || {},\n        color: d.color,\n        isPremium: d.is_premium,\n      }));\n\n      set({ nodeTemplates: templates });\n    } catch (error) {\n      console.error(\"Failed to load node templates:\", error);\n    }\n  },\n\n  // Create new workflow\n  createNewWorkflow: async (name, category = \"general\") => {\n    const {\n      data: { user },\n    } = await supabase.auth.getUser();\n    if (!user) {\n      toast.error(\"Not authenticated\");\n      return;\n    }\n\n    const workflow = createDefaultWorkflow(user.id, name, category);\n    get().setWorkflow(workflow);\n  },\n\n  // Select node\n  selectNode: (nodeId) => {\n    set({ selectedNodeId: nodeId, selectedEdgeId: null });\n  },\n\n  // Add node\n  addNode: (type, subtype, position, config = {}) => {\n    const { workflow, nodeTemplates, pushToHistory } = get();\n    if (!workflow) return;\n\n    const template = nodeTemplates.find(\n      (t) => t.type === type && t.subtype === subtype\n    );\n\n    const newNode: WorkflowNode = {\n      id: generateId(),\n      type,\n      subtype,\n      label: template?.name || subtype,\n      description: template?.description,\n      position,\n      config: { ...template?.defaultConfig, ...config },\n      outputs: type === \"condition\" ? [\"true\", \"false\"] : undefined,\n    };\n\n    const newWorkflow = {\n      ...workflow,\n      nodes: [...workflow.nodes, newNode],\n      updatedAt: new Date().toISOString(),\n    };\n\n    pushToHistory();\n    set({\n      workflow: newWorkflow,\n      selectedNodeId: newNode.id,\n    });\n  },\n\n  // Update node\n  updateNode: (nodeId, updates) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    const newNodes = workflow.nodes.map((node) =>\n      node.id === nodeId ? { ...node, ...updates } : node\n    );\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        nodes: newNodes,\n        updatedAt: new Date().toISOString(),\n      },\n    });\n  },\n\n  // Remove node\n  removeNode: (nodeId) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    // Remove node and connected edges\n    const newNodes = workflow.nodes.filter((n) => n.id !== nodeId);\n    const newEdges = workflow.edges.filter(\n      (e) => e.source !== nodeId && e.target !== nodeId\n    );\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        nodes: newNodes,\n        edges: newEdges,\n        updatedAt: new Date().toISOString(),\n      },\n      selectedNodeId: null,\n    });\n  },\n\n  // Duplicate node\n  duplicateNode: (nodeId) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    const node = workflow.nodes.find((n) => n.id === nodeId);\n    if (!node) return;\n\n    const newNode: WorkflowNode = {\n      ...node,\n      id: generateId(),\n      label: `${node.label} (copy)`,\n      position: {\n        x: node.position.x + 50,\n        y: node.position.y + 50,\n      },\n    };\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        nodes: [...workflow.nodes, newNode],\n        updatedAt: new Date().toISOString(),\n      },\n      selectedNodeId: newNode.id,\n    });\n  },\n\n  // Select edge\n  selectEdge: (edgeId) => {\n    set({ selectedEdgeId: edgeId, selectedNodeId: null });\n  },\n\n  // Add edge\n  addEdge: (source, target, sourceHandle, label) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    // Check if edge already exists\n    const exists = workflow.edges.some(\n      (e) =>\n        e.source === source &&\n        e.target === target &&\n        e.sourceHandle === sourceHandle\n    );\n    if (exists) return;\n\n    // Prevent self-loops\n    if (source === target) return;\n\n    const newEdge: WorkflowEdge = {\n      id: generateId(),\n      source,\n      target,\n      sourceHandle,\n      label,\n    };\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        edges: [...workflow.edges, newEdge],\n        updatedAt: new Date().toISOString(),\n      },\n    });\n  },\n\n  // Update edge\n  updateEdge: (edgeId, updates) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    const newEdges = workflow.edges.map((edge) =>\n      edge.id === edgeId ? { ...edge, ...updates } : edge\n    );\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        edges: newEdges,\n        updatedAt: new Date().toISOString(),\n      },\n    });\n  },\n\n  // Remove edge\n  removeEdge: (edgeId) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    const newEdges = workflow.edges.filter((e) => e.id !== edgeId);\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        edges: newEdges,\n        updatedAt: new Date().toISOString(),\n      },\n      selectedEdgeId: null,\n    });\n  },\n\n  // Connection handling\n  startConnection: (nodeId) => {\n    set({ isConnecting: true, connectionStart: nodeId });\n  },\n\n  completeConnection: (nodeId) => {\n    const { connectionStart, addEdge } = get();\n    if (connectionStart && connectionStart !== nodeId) {\n      addEdge(connectionStart, nodeId);\n    }\n    set({ isConnecting: false, connectionStart: null });\n  },\n\n  cancelConnection: () => {\n    set({ isConnecting: false, connectionStart: null });\n  },\n\n  // Update viewport\n  updateViewport: (viewport) => {\n    const { workflow } = get();\n    if (!workflow) return;\n\n    set({\n      workflow: {\n        ...workflow,\n        viewport: { ...workflow.viewport, ...viewport },\n      },\n    });\n  },\n\n  // Set dragging state\n  setIsDragging: (isDragging) => {\n    set({ isDragging });\n  },\n\n  // Push current state to history\n  pushToHistory: () => {\n    const { workflow, history, historyIndex } = get();\n    if (!workflow) return;\n\n    const newHistory = history.slice(0, historyIndex + 1);\n    newHistory.push(JSON.parse(JSON.stringify(workflow)));\n\n    set({\n      history: newHistory,\n      historyIndex: newHistory.length - 1,\n    });\n  },\n\n  // Undo\n  undo: () => {\n    const { history, historyIndex } = get();\n    if (historyIndex > 0) {\n      set({\n        workflow: JSON.parse(JSON.stringify(history[historyIndex - 1])),\n        historyIndex: historyIndex - 1,\n        selectedNodeId: null,\n        selectedEdgeId: null,\n      });\n    }\n  },\n\n  // Redo\n  redo: () => {\n    const { history, historyIndex } = get();\n    if (historyIndex < history.length - 1) {\n      set({\n        workflow: JSON.parse(JSON.stringify(history[historyIndex + 1])),\n        historyIndex: historyIndex + 1,\n        selectedNodeId: null,\n        selectedEdgeId: null,\n      });\n    }\n  },\n\n  // Can undo\n  canUndo: () => {\n    const { historyIndex } = get();\n    return historyIndex > 0;\n  },\n\n  // Can redo\n  canRedo: () => {\n    const { history, historyIndex } = get();\n    return historyIndex < history.length - 1;\n  },\n\n  // Save workflow\n  saveWorkflow: async () => {\n    const { workflow } = get();\n    if (!workflow) return;\n\n    set({ isSaving: true });\n\n    try {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) throw new Error(\"Not authenticated\");\n\n      const workflowData = {\n        user_id: user.id,\n        name: workflow.name,\n        description: workflow.description,\n        category: workflow.category,\n        nodes: workflow.nodes,\n        edges: workflow.edges,\n        viewport: workflow.viewport,\n        is_published: workflow.isPublished,\n        is_active: workflow.isActive,\n        trigger_config: workflow.triggerConfig,\n        tags: workflow.tags,\n      };\n\n      // Check if workflow exists\n      const { data: existing } = await supabase\n        .from(\"workflows\")\n        .select(\"id\")\n        .eq(\"id\", workflow.id)\n        .single();\n\n      if (existing) {\n        // Update existing\n        const { error } = await supabase\n          .from(\"workflows\")\n          .update(workflowData)\n          .eq(\"id\", workflow.id);\n\n        if (error) throw error;\n      } else {\n        // Insert new\n        const { error } = await supabase\n          .from(\"workflows\")\n          .insert({ ...workflowData, id: workflow.id });\n\n        if (error) throw error;\n      }\n\n      toast.success(\"Workflow saved\");\n    } catch (error) {\n      console.error(\"Failed to save workflow:\", error);\n      toast.error(\"Failed to save workflow\");\n      throw error;\n    } finally {\n      set({ isSaving: false });\n    }\n  },\n\n  // Publish workflow\n  publishWorkflow: async () => {\n    const { workflow, saveWorkflow } = get();\n    if (!workflow) return;\n\n    set({\n      workflow: {\n        ...workflow,\n        isPublished: true,\n        updatedAt: new Date().toISOString(),\n      },\n    });\n\n    await saveWorkflow();\n    toast.success(\"Workflow published\");\n  },\n\n  // Activate/deactivate workflow\n  activateWorkflow: async (active) => {\n    const { workflow, saveWorkflow } = get();\n    if (!workflow) return;\n\n    set({\n      workflow: {\n        ...workflow,\n        isActive: active,\n        updatedAt: new Date().toISOString(),\n      },\n    });\n\n    await saveWorkflow();\n    toast.success(active ? \"Workflow activated\" : \"Workflow deactivated\");\n  },\n\n  // Execute workflow manually\n  executeWorkflow: async (triggerData = {}) => {\n    const { workflow } = get();\n    if (!workflow) throw new Error(\"No workflow loaded\");\n\n    set({ isExecuting: true });\n\n    try {\n      const { data, error } = await supabase.rpc(\"start_workflow_execution\", {\n        p_workflow_id: workflow.id,\n        p_trigger_type: \"manual\",\n        p_trigger_data: triggerData,\n      });\n\n      if (error) throw error;\n\n      toast.success(\"Workflow execution started\");\n      return data as string;\n    } catch (error) {\n      console.error(\"Failed to execute workflow:\", error);\n      toast.error(\"Failed to execute workflow\");\n      throw error;\n    } finally {\n      set({ isExecuting: false });\n    }\n  },\n\n  // Update workflow metadata\n  updateWorkflowMeta: (meta) => {\n    const { workflow, pushToHistory } = get();\n    if (!workflow) return;\n\n    pushToHistory();\n    set({\n      workflow: {\n        ...workflow,\n        ...meta,\n        updatedAt: new Date().toISOString(),\n      },\n    });\n  },\n\n  // Reset builder\n  resetBuilder: () => {\n    set({\n      workflow: null,\n      selectedNodeId: null,\n      selectedEdgeId: null,\n      isDragging: false,\n      isConnecting: false,\n      connectionStart: null,\n      history: [],\n      historyIndex: -1,\n      isSaving: false,\n      isExecuting: false,\n    });\n  },\n}));\n"],"names":["generateId","createDefaultWorkflow","userId","name","category","useWorkflowBuilderStore","create","set","get","workflow","workflowId","data","error","supabase","toast","user","d","templates","nodeId","type","subtype","position","config","nodeTemplates","pushToHistory","template","t","newNode","newWorkflow","updates","newNodes","node","n","newEdges","e","edgeId","source","target","sourceHandle","label","newEdge","edge","connectionStart","addEdge","viewport","isDragging","history","historyIndex","newHistory","workflowData","existing","saveWorkflow","active","triggerData","meta"],"mappings":"+FA0FA,MAAMA,EAAa,IAAM,OAAO,WAAA,EAE1BC,EAAwB,CAC5BC,EACAC,EACAC,EAA6B,aACf,CACd,GAAIJ,EAAA,EACJ,OAAAE,EACA,KAAAC,EACA,YAAa,GACb,SAAAC,EACA,MAAO,CAAA,EACP,MAAO,CAAA,EACP,SAAU,CAAE,EAAG,EAAG,EAAG,EAAG,KAAM,CAAA,EAC9B,YAAa,GACb,SAAU,GACV,QAAS,EACT,eAAgB,EAChB,aAAc,EACd,aAAc,EACd,KAAM,CAAA,EACN,UAAW,IAAI,KAAA,EAAO,YAAA,EACtB,UAAW,IAAI,KAAA,EAAO,YAAA,CACxB,GAEaC,EAA0BC,EAA6B,CAACC,EAAKC,KAAS,CAEjF,SAAU,KACV,eAAgB,KAChB,eAAgB,KAChB,WAAY,GACZ,aAAc,GACd,gBAAiB,KACjB,QAAS,CAAA,EACT,aAAc,GACd,SAAU,GACV,YAAa,GACb,cAAe,CAAA,EAGf,YAAcC,GAAa,CACzBF,EAAI,CACF,SAAAE,EACA,QAAS,CAACA,CAAQ,EAClB,aAAc,EACd,eAAgB,KAChB,eAAgB,IAAA,CACjB,CACH,EAGA,aAAc,MAAOC,GAAe,CAClC,GAAI,CACF,KAAM,CAAE,KAAAC,EAAM,MAAAC,CAAA,EAAU,MAAMC,EAC3B,KAAK,WAAW,EAChB,OAAO,GAAG,EACV,GAAG,KAAMH,CAAU,EACnB,OAAA,EAEH,GAAIE,EAAO,MAAMA,EACjB,GAAI,CAACD,EAAM,MAAM,IAAI,MAAM,oBAAoB,EAE/C,MAAMF,EAAqB,CACzB,GAAIE,EAAK,GACT,OAAQA,EAAK,QACb,KAAMA,EAAK,KACX,YAAaA,EAAK,aAAe,GACjC,SAAUA,EAAK,SACf,MAAQA,EAAK,OAA4B,CAAA,EACzC,MAAQA,EAAK,OAA4B,CAAA,EACzC,SAAWA,EAAK,UAAiC,CAAE,EAAG,EAAG,EAAG,EAAG,KAAM,CAAA,EACrE,YAAaA,EAAK,aAClB,SAAUA,EAAK,UACf,cAAeA,EAAK,eACpB,QAASA,EAAK,QACd,eAAgBA,EAAK,gBACrB,aAAcA,EAAK,cACnB,aAAcA,EAAK,cACnB,eAAgBA,EAAK,iBACrB,KAAMA,EAAK,MAAQ,CAAA,EACnB,UAAWA,EAAK,WAChB,UAAWA,EAAK,UAAA,EAGlBH,EAAA,EAAM,YAAYC,CAAQ,CAC5B,OAASG,EAAO,CACd,cAAQ,MAAM,2BAA4BA,CAAK,EAC/CE,EAAM,MAAM,yBAAyB,EAC/BF,CACR,CACF,EAGA,kBAAmB,SAAY,CAC7B,GAAI,CACF,KAAM,CACJ,KAAM,CAAE,KAAAG,CAAA,CAAK,EACX,MAAMF,EAAS,KAAK,QAAA,EACxB,GAAI,CAACE,EAAM,MAAM,IAAI,MAAM,mBAAmB,EAE9C,KAAM,CAAE,KAAAJ,EAAM,MAAAC,GAAU,MAAMC,EAC3B,KAAK,WAAW,EAChB,OAAO,GAAG,EACV,GAAG,UAAWE,EAAK,EAAE,EACrB,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAIH,EAAO,MAAMA,EAEjB,OAAQD,GAAQ,CAAA,GAAI,IAAKK,IAAO,CAC9B,GAAIA,EAAE,GACN,OAAQA,EAAE,QACV,KAAMA,EAAE,KACR,YAAaA,EAAE,aAAe,GAC9B,SAAUA,EAAE,SACZ,MAAQA,EAAE,OAA4B,CAAA,EACtC,MAAQA,EAAE,OAA4B,CAAA,EACtC,SAAWA,EAAE,UAAiC,CAAE,EAAG,EAAG,EAAG,EAAG,KAAM,CAAA,EAClE,YAAaA,EAAE,aACf,SAAUA,EAAE,UACZ,cAAeA,EAAE,eACjB,QAASA,EAAE,QACX,eAAgBA,EAAE,gBAClB,aAAcA,EAAE,cAChB,aAAcA,EAAE,cAChB,eAAgBA,EAAE,iBAClB,KAAMA,EAAE,MAAQ,CAAA,EAChB,UAAWA,EAAE,WACb,UAAWA,EAAE,UAAA,EACb,CACJ,OAASJ,EAAO,CACd,eAAQ,MAAM,4BAA6BA,CAAK,EACzC,CAAA,CACT,CACF,EAGA,kBAAmB,SAAY,CAC7B,GAAI,CACF,KAAM,CAAE,KAAAD,EAAM,MAAAC,CAAA,EAAU,MAAMC,EAC3B,KAAK,yBAAyB,EAC9B,OAAO,GAAG,EACV,GAAG,YAAa,EAAI,EACpB,MAAM,UAAU,EAEnB,GAAID,EAAO,MAAMA,EAEjB,MAAMK,GAAqCN,GAAQ,CAAA,GAAI,IAAKK,IAAO,CACjE,GAAIA,EAAE,GACN,KAAMA,EAAE,KACR,QAASA,EAAE,QACX,KAAMA,EAAE,KACR,YAAaA,EAAE,YACf,KAAMA,EAAE,KACR,SAAUA,EAAE,SACZ,aAAcA,EAAE,eAAiB,CAAA,EACjC,cAAeA,EAAE,gBAAkB,CAAA,EACnC,MAAOA,EAAE,MACT,UAAWA,EAAE,UAAA,EACb,EAEFT,EAAI,CAAE,cAAeU,EAAW,CAClC,OAASL,EAAO,CACd,QAAQ,MAAM,iCAAkCA,CAAK,CACvD,CACF,EAGA,kBAAmB,MAAOT,EAAMC,EAAW,YAAc,CACvD,KAAM,CACJ,KAAM,CAAE,KAAAW,CAAA,CAAK,EACX,MAAMF,EAAS,KAAK,QAAA,EACxB,GAAI,CAACE,EAAM,CACTD,EAAM,MAAM,mBAAmB,EAC/B,MACF,CAEA,MAAML,EAAWR,EAAsBc,EAAK,GAAIZ,EAAMC,CAAQ,EAC9DI,EAAA,EAAM,YAAYC,CAAQ,CAC5B,EAGA,WAAaS,GAAW,CACtBX,EAAI,CAAE,eAAgBW,EAAQ,eAAgB,KAAM,CACtD,EAGA,QAAS,CAACC,EAAMC,EAASC,EAAUC,EAAS,CAAA,IAAO,CACjD,KAAM,CAAE,SAAAb,EAAU,cAAAc,EAAe,cAAAC,CAAA,EAAkBhB,EAAA,EACnD,GAAI,CAACC,EAAU,OAEf,MAAMgB,EAAWF,EAAc,KAC5BG,GAAMA,EAAE,OAASP,GAAQO,EAAE,UAAYN,CAAA,EAGpCO,EAAwB,CAC5B,GAAI3B,EAAA,EACJ,KAAAmB,EACA,QAAAC,EACA,MAAOK,GAAU,MAAQL,EACzB,YAAaK,GAAU,YACvB,SAAAJ,EACA,OAAQ,CAAE,GAAGI,GAAU,cAAe,GAAGH,CAAA,EACzC,QAASH,IAAS,YAAc,CAAC,OAAQ,OAAO,EAAI,MAAA,EAGhDS,EAAc,CAClB,GAAGnB,EACH,MAAO,CAAC,GAAGA,EAAS,MAAOkB,CAAO,EAClC,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,EAGpCH,EAAA,EACAjB,EAAI,CACF,SAAUqB,EACV,eAAgBD,EAAQ,EAAA,CACzB,CACH,EAGA,WAAY,CAACT,EAAQW,IAAY,CAC/B,KAAM,CAAE,SAAApB,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EACpC,GAAI,CAACC,EAAU,OAEf,MAAMqB,EAAWrB,EAAS,MAAM,IAAKsB,GACnCA,EAAK,KAAOb,EAAS,CAAE,GAAGa,EAAM,GAAGF,GAAYE,CAAA,EAGjDP,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAOqB,EACP,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,CACH,EAGA,WAAaZ,GAAW,CACtB,KAAM,CAAE,SAAAT,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EACpC,GAAI,CAACC,EAAU,OAGf,MAAMqB,EAAWrB,EAAS,MAAM,OAAQuB,GAAMA,EAAE,KAAOd,CAAM,EACvDe,EAAWxB,EAAS,MAAM,OAC7ByB,GAAMA,EAAE,SAAWhB,GAAUgB,EAAE,SAAWhB,CAAA,EAG7CM,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAOqB,EACP,MAAOG,EACP,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,EAEpC,eAAgB,IAAA,CACjB,CACH,EAGA,cAAgBf,GAAW,CACzB,KAAM,CAAE,SAAAT,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EACpC,GAAI,CAACC,EAAU,OAEf,MAAMsB,EAAOtB,EAAS,MAAM,KAAMuB,GAAMA,EAAE,KAAOd,CAAM,EACvD,GAAI,CAACa,EAAM,OAEX,MAAMJ,EAAwB,CAC5B,GAAGI,EACH,GAAI/B,EAAA,EACJ,MAAO,GAAG+B,EAAK,KAAK,UACpB,SAAU,CACR,EAAGA,EAAK,SAAS,EAAI,GACrB,EAAGA,EAAK,SAAS,EAAI,EAAA,CACvB,EAGFP,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAO,CAAC,GAAGA,EAAS,MAAOkB,CAAO,EAClC,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,EAEpC,eAAgBA,EAAQ,EAAA,CACzB,CACH,EAGA,WAAaQ,GAAW,CACtB5B,EAAI,CAAE,eAAgB4B,EAAQ,eAAgB,KAAM,CACtD,EAGA,QAAS,CAACC,EAAQC,EAAQC,EAAcC,IAAU,CAChD,KAAM,CAAE,SAAA9B,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EAapC,GAZI,CAACC,GAGUA,EAAS,MAAM,KAC3ByB,GACCA,EAAE,SAAWE,GACbF,EAAE,SAAWG,GACbH,EAAE,eAAiBI,CAAA,GAKnBF,IAAWC,EAAQ,OAEvB,MAAMG,EAAwB,CAC5B,GAAIxC,EAAA,EACJ,OAAAoC,EACA,OAAAC,EACA,aAAAC,EACA,MAAAC,CAAA,EAGFf,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAO,CAAC,GAAGA,EAAS,MAAO+B,CAAO,EAClC,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,CACH,EAGA,WAAY,CAACL,EAAQN,IAAY,CAC/B,KAAM,CAAE,SAAApB,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EACpC,GAAI,CAACC,EAAU,OAEf,MAAMwB,EAAWxB,EAAS,MAAM,IAAKgC,GACnCA,EAAK,KAAON,EAAS,CAAE,GAAGM,EAAM,GAAGZ,GAAYY,CAAA,EAGjDjB,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAOwB,EACP,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,CACH,EAGA,WAAaE,GAAW,CACtB,KAAM,CAAE,SAAA1B,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EACpC,GAAI,CAACC,EAAU,OAEf,MAAMwB,EAAWxB,EAAS,MAAM,OAAQyB,GAAMA,EAAE,KAAOC,CAAM,EAE7DX,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,MAAOwB,EACP,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,EAEpC,eAAgB,IAAA,CACjB,CACH,EAGA,gBAAkBf,GAAW,CAC3BX,EAAI,CAAE,aAAc,GAAM,gBAAiBW,EAAQ,CACrD,EAEA,mBAAqBA,GAAW,CAC9B,KAAM,CAAE,gBAAAwB,EAAiB,QAAAC,CAAA,EAAYnC,EAAA,EACjCkC,GAAmBA,IAAoBxB,GACzCyB,EAAQD,EAAiBxB,CAAM,EAEjCX,EAAI,CAAE,aAAc,GAAO,gBAAiB,KAAM,CACpD,EAEA,iBAAkB,IAAM,CACtBA,EAAI,CAAE,aAAc,GAAO,gBAAiB,KAAM,CACpD,EAGA,eAAiBqC,GAAa,CAC5B,KAAM,CAAE,SAAAnC,CAAA,EAAaD,EAAA,EAChBC,GAELF,EAAI,CACF,SAAU,CACR,GAAGE,EACH,SAAU,CAAE,GAAGA,EAAS,SAAU,GAAGmC,CAAA,CAAS,CAChD,CACD,CACH,EAGA,cAAgBC,GAAe,CAC7BtC,EAAI,CAAE,WAAAsC,EAAY,CACpB,EAGA,cAAe,IAAM,CACnB,KAAM,CAAE,SAAApC,EAAU,QAAAqC,EAAS,aAAAC,CAAA,EAAiBvC,EAAA,EAC5C,GAAI,CAACC,EAAU,OAEf,MAAMuC,EAAaF,EAAQ,MAAM,EAAGC,EAAe,CAAC,EACpDC,EAAW,KAAK,KAAK,MAAM,KAAK,UAAUvC,CAAQ,CAAC,CAAC,EAEpDF,EAAI,CACF,QAASyC,EACT,aAAcA,EAAW,OAAS,CAAA,CACnC,CACH,EAGA,KAAM,IAAM,CACV,KAAM,CAAE,QAAAF,EAAS,aAAAC,CAAA,EAAiBvC,EAAA,EAC9BuC,EAAe,GACjBxC,EAAI,CACF,SAAU,KAAK,MAAM,KAAK,UAAUuC,EAAQC,EAAe,CAAC,CAAC,CAAC,EAC9D,aAAcA,EAAe,EAC7B,eAAgB,KAChB,eAAgB,IAAA,CACjB,CAEL,EAGA,KAAM,IAAM,CACV,KAAM,CAAE,QAAAD,EAAS,aAAAC,CAAA,EAAiBvC,EAAA,EAC9BuC,EAAeD,EAAQ,OAAS,GAClCvC,EAAI,CACF,SAAU,KAAK,MAAM,KAAK,UAAUuC,EAAQC,EAAe,CAAC,CAAC,CAAC,EAC9D,aAAcA,EAAe,EAC7B,eAAgB,KAChB,eAAgB,IAAA,CACjB,CAEL,EAGA,QAAS,IAAM,CACb,KAAM,CAAE,aAAAA,CAAA,EAAiBvC,EAAA,EACzB,OAAOuC,EAAe,CACxB,EAGA,QAAS,IAAM,CACb,KAAM,CAAE,QAAAD,EAAS,aAAAC,CAAA,EAAiBvC,EAAA,EAClC,OAAOuC,EAAeD,EAAQ,OAAS,CACzC,EAGA,aAAc,SAAY,CACxB,KAAM,CAAE,SAAArC,CAAA,EAAaD,EAAA,EACrB,GAAKC,EAEL,CAAAF,EAAI,CAAE,SAAU,GAAM,EAEtB,GAAI,CACF,KAAM,CACJ,KAAM,CAAE,KAAAQ,CAAA,CAAK,EACX,MAAMF,EAAS,KAAK,QAAA,EACxB,GAAI,CAACE,EAAM,MAAM,IAAI,MAAM,mBAAmB,EAE9C,MAAMkC,EAAe,CACnB,QAASlC,EAAK,GACd,KAAMN,EAAS,KACf,YAAaA,EAAS,YACtB,SAAUA,EAAS,SACnB,MAAOA,EAAS,MAChB,MAAOA,EAAS,MAChB,SAAUA,EAAS,SACnB,aAAcA,EAAS,YACvB,UAAWA,EAAS,SACpB,eAAgBA,EAAS,cACzB,KAAMA,EAAS,IAAA,EAIX,CAAE,KAAMyC,CAAA,EAAa,MAAMrC,EAC9B,KAAK,WAAW,EAChB,OAAO,IAAI,EACX,GAAG,KAAMJ,EAAS,EAAE,EACpB,OAAA,EAEH,GAAIyC,EAAU,CAEZ,KAAM,CAAE,MAAAtC,CAAA,EAAU,MAAMC,EACrB,KAAK,WAAW,EAChB,OAAOoC,CAAY,EACnB,GAAG,KAAMxC,EAAS,EAAE,EAEvB,GAAIG,EAAO,MAAMA,CACnB,KAAO,CAEL,KAAM,CAAE,MAAAA,CAAA,EAAU,MAAMC,EACrB,KAAK,WAAW,EAChB,OAAO,CAAE,GAAGoC,EAAc,GAAIxC,EAAS,GAAI,EAE9C,GAAIG,EAAO,MAAMA,CACnB,CAEAE,EAAM,QAAQ,gBAAgB,CAChC,OAASF,EAAO,CACd,cAAQ,MAAM,2BAA4BA,CAAK,EAC/CE,EAAM,MAAM,yBAAyB,EAC/BF,CACR,QAAA,CACEL,EAAI,CAAE,SAAU,GAAO,CACzB,EACF,EAGA,gBAAiB,SAAY,CAC3B,KAAM,CAAE,SAAAE,EAAU,aAAA0C,CAAA,EAAiB3C,EAAA,EAC9BC,IAELF,EAAI,CACF,SAAU,CACR,GAAGE,EACH,YAAa,GACb,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,EAED,MAAM0C,EAAA,EACNrC,EAAM,QAAQ,oBAAoB,EACpC,EAGA,iBAAkB,MAAOsC,GAAW,CAClC,KAAM,CAAE,SAAA3C,EAAU,aAAA0C,CAAA,EAAiB3C,EAAA,EAC9BC,IAELF,EAAI,CACF,SAAU,CACR,GAAGE,EACH,SAAU2C,EACV,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,EAED,MAAMD,EAAA,EACNrC,EAAM,QAAQsC,EAAS,qBAAuB,sBAAsB,EACtE,EAGA,gBAAiB,MAAOC,EAAc,KAAO,CAC3C,KAAM,CAAE,SAAA5C,CAAA,EAAaD,EAAA,EACrB,GAAI,CAACC,EAAU,MAAM,IAAI,MAAM,oBAAoB,EAEnDF,EAAI,CAAE,YAAa,GAAM,EAEzB,GAAI,CACF,KAAM,CAAE,KAAAI,EAAM,MAAAC,CAAA,EAAU,MAAMC,EAAS,IAAI,2BAA4B,CACrE,cAAeJ,EAAS,GACxB,eAAgB,SAChB,eAAgB4C,CAAA,CACjB,EAED,GAAIzC,EAAO,MAAMA,EAEjBE,OAAAA,EAAM,QAAQ,4BAA4B,EACnCH,CACT,OAASC,EAAO,CACd,cAAQ,MAAM,8BAA+BA,CAAK,EAClDE,EAAM,MAAM,4BAA4B,EAClCF,CACR,QAAA,CACEL,EAAI,CAAE,YAAa,GAAO,CAC5B,CACF,EAGA,mBAAqB+C,GAAS,CAC5B,KAAM,CAAE,SAAA7C,EAAU,cAAAe,CAAA,EAAkBhB,EAAA,EAC/BC,IAELe,EAAA,EACAjB,EAAI,CACF,SAAU,CACR,GAAGE,EACH,GAAG6C,EACH,UAAW,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,CACD,EACH,EAGA,aAAc,IAAM,CAClB/C,EAAI,CACF,SAAU,KACV,eAAgB,KAChB,eAAgB,KAChB,WAAY,GACZ,aAAc,GACd,gBAAiB,KACjB,QAAS,CAAA,EACT,aAAc,GACd,SAAU,GACV,YAAa,EAAA,CACd,CACH,CACF,EAAE"}
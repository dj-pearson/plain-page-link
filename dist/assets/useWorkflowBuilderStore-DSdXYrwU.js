import{bT as k,s as d,af as l}from"./index-BOhoRjKs.js";const u=()=>crypto.randomUUID(),h=(s,i,o="general")=>({id:u(),userId:s,name:i,description:"",category:o,nodes:[],edges:[],viewport:{x:0,y:0,zoom:1},isPublished:!1,isActive:!1,version:1,executionCount:0,successCount:0,failureCount:0,tags:[],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()}),m=k((s,i)=>({workflow:null,selectedNodeId:null,selectedEdgeId:null,isDragging:!1,isConnecting:!1,connectionStart:null,history:[],historyIndex:-1,isSaving:!1,isExecuting:!1,nodeTemplates:[],setWorkflow:o=>{s({workflow:o,history:[o],historyIndex:0,selectedNodeId:null,selectedEdgeId:null})},loadWorkflow:async o=>{try{const{data:e,error:r}=await d.from("workflows").select("*").eq("id",o).single();if(r)throw r;if(!e)throw new Error("Workflow not found");const t={id:e.id,userId:e.user_id,name:e.name,description:e.description||"",category:e.category,nodes:e.nodes||[],edges:e.edges||[],viewport:e.viewport||{x:0,y:0,zoom:1},isPublished:e.is_published,isActive:e.is_active,triggerConfig:e.trigger_config,version:e.version,executionCount:e.execution_count,successCount:e.success_count,failureCount:e.failure_count,lastExecutedAt:e.last_executed_at,tags:e.tags||[],createdAt:e.created_at,updatedAt:e.updated_at};i().setWorkflow(t)}catch(e){throw console.error("Failed to load workflow:",e),l.error("Failed to load workflow"),e}},loadUserWorkflows:async()=>{try{const{data:{user:o}}=await d.auth.getUser();if(!o)throw new Error("Not authenticated");const{data:e,error:r}=await d.from("workflows").select("*").eq("user_id",o.id).order("updated_at",{ascending:!1});if(r)throw r;return(e||[]).map(t=>({id:t.id,userId:t.user_id,name:t.name,description:t.description||"",category:t.category,nodes:t.nodes||[],edges:t.edges||[],viewport:t.viewport||{x:0,y:0,zoom:1},isPublished:t.is_published,isActive:t.is_active,triggerConfig:t.trigger_config,version:t.version,executionCount:t.execution_count,successCount:t.success_count,failureCount:t.failure_count,lastExecutedAt:t.last_executed_at,tags:t.tags||[],createdAt:t.created_at,updatedAt:t.updated_at}))}catch(o){return console.error("Failed to load workflows:",o),[]}},loadNodeTemplates:async()=>{try{const{data:o,error:e}=await d.from("workflow_node_templates").select("*").eq("is_active",!0).order("category");if(e)throw e;const r=(o||[]).map(t=>({id:t.id,type:t.type,subtype:t.subtype,name:t.name,description:t.description,icon:t.icon,category:t.category,configSchema:t.config_schema||{},defaultConfig:t.default_config||{},color:t.color,isPremium:t.is_premium}));s({nodeTemplates:r})}catch(o){console.error("Failed to load node templates:",o)}},createNewWorkflow:async(o,e="general")=>{const{data:{user:r}}=await d.auth.getUser();if(!r){l.error("Not authenticated");return}const t=h(r.id,o,e);i().setWorkflow(t)},selectNode:o=>{s({selectedNodeId:o,selectedEdgeId:null})},addNode:(o,e,r,t={})=>{const{workflow:n,nodeTemplates:a,pushToHistory:f}=i();if(!n)return;const w=a.find(g=>g.type===o&&g.subtype===e),c={id:u(),type:o,subtype:e,label:w?.name||e,description:w?.description,position:r,config:{...w?.defaultConfig,...t},outputs:o==="condition"?["true","false"]:void 0},p={...n,nodes:[...n.nodes,c],updatedAt:new Date().toISOString()};f(),s({workflow:p,selectedNodeId:c.id})},updateNode:(o,e)=>{const{workflow:r,pushToHistory:t}=i();if(!r)return;const n=r.nodes.map(a=>a.id===o?{...a,...e}:a);t(),s({workflow:{...r,nodes:n,updatedAt:new Date().toISOString()}})},removeNode:o=>{const{workflow:e,pushToHistory:r}=i();if(!e)return;const t=e.nodes.filter(a=>a.id!==o),n=e.edges.filter(a=>a.source!==o&&a.target!==o);r(),s({workflow:{...e,nodes:t,edges:n,updatedAt:new Date().toISOString()},selectedNodeId:null})},duplicateNode:o=>{const{workflow:e,pushToHistory:r}=i();if(!e)return;const t=e.nodes.find(a=>a.id===o);if(!t)return;const n={...t,id:u(),label:`${t.label} (copy)`,position:{x:t.position.x+50,y:t.position.y+50}};r(),s({workflow:{...e,nodes:[...e.nodes,n],updatedAt:new Date().toISOString()},selectedNodeId:n.id})},selectEdge:o=>{s({selectedEdgeId:o,selectedNodeId:null})},addEdge:(o,e,r,t)=>{const{workflow:n,pushToHistory:a}=i();if(!n||n.edges.some(c=>c.source===o&&c.target===e&&c.sourceHandle===r)||o===e)return;const w={id:u(),source:o,target:e,sourceHandle:r,label:t};a(),s({workflow:{...n,edges:[...n.edges,w],updatedAt:new Date().toISOString()}})},updateEdge:(o,e)=>{const{workflow:r,pushToHistory:t}=i();if(!r)return;const n=r.edges.map(a=>a.id===o?{...a,...e}:a);t(),s({workflow:{...r,edges:n,updatedAt:new Date().toISOString()}})},removeEdge:o=>{const{workflow:e,pushToHistory:r}=i();if(!e)return;const t=e.edges.filter(n=>n.id!==o);r(),s({workflow:{...e,edges:t,updatedAt:new Date().toISOString()},selectedEdgeId:null})},startConnection:o=>{s({isConnecting:!0,connectionStart:o})},completeConnection:o=>{const{connectionStart:e,addEdge:r}=i();e&&e!==o&&r(e,o),s({isConnecting:!1,connectionStart:null})},cancelConnection:()=>{s({isConnecting:!1,connectionStart:null})},updateViewport:o=>{const{workflow:e}=i();e&&s({workflow:{...e,viewport:{...e.viewport,...o}}})},setIsDragging:o=>{s({isDragging:o})},pushToHistory:()=>{const{workflow:o,history:e,historyIndex:r}=i();if(!o)return;const t=e.slice(0,r+1);t.push(JSON.parse(JSON.stringify(o))),s({history:t,historyIndex:t.length-1})},undo:()=>{const{history:o,historyIndex:e}=i();e>0&&s({workflow:JSON.parse(JSON.stringify(o[e-1])),historyIndex:e-1,selectedNodeId:null,selectedEdgeId:null})},redo:()=>{const{history:o,historyIndex:e}=i();e<o.length-1&&s({workflow:JSON.parse(JSON.stringify(o[e+1])),historyIndex:e+1,selectedNodeId:null,selectedEdgeId:null})},canUndo:()=>{const{historyIndex:o}=i();return o>0},canRedo:()=>{const{history:o,historyIndex:e}=i();return e<o.length-1},saveWorkflow:async()=>{const{workflow:o}=i();if(o){s({isSaving:!0});try{const{data:{user:e}}=await d.auth.getUser();if(!e)throw new Error("Not authenticated");const r={user_id:e.id,name:o.name,description:o.description,category:o.category,nodes:o.nodes,edges:o.edges,viewport:o.viewport,is_published:o.isPublished,is_active:o.isActive,trigger_config:o.triggerConfig,tags:o.tags},{data:t}=await d.from("workflows").select("id").eq("id",o.id).single();if(t){const{error:n}=await d.from("workflows").update(r).eq("id",o.id);if(n)throw n}else{const{error:n}=await d.from("workflows").insert({...r,id:o.id});if(n)throw n}l.success("Workflow saved")}catch(e){throw console.error("Failed to save workflow:",e),l.error("Failed to save workflow"),e}finally{s({isSaving:!1})}}},publishWorkflow:async()=>{const{workflow:o,saveWorkflow:e}=i();o&&(s({workflow:{...o,isPublished:!0,updatedAt:new Date().toISOString()}}),await e(),l.success("Workflow published"))},activateWorkflow:async o=>{const{workflow:e,saveWorkflow:r}=i();e&&(s({workflow:{...e,isActive:o,updatedAt:new Date().toISOString()}}),await r(),l.success(o?"Workflow activated":"Workflow deactivated"))},executeWorkflow:async(o={})=>{const{workflow:e}=i();if(!e)throw new Error("No workflow loaded");s({isExecuting:!0});try{const{data:r,error:t}=await d.rpc("start_workflow_execution",{p_workflow_id:e.id,p_trigger_type:"manual",p_trigger_data:o});if(t)throw t;return l.success("Workflow execution started"),r}catch(r){throw console.error("Failed to execute workflow:",r),l.error("Failed to execute workflow"),r}finally{s({isExecuting:!1})}},updateWorkflowMeta:o=>{const{workflow:e,pushToHistory:r}=i();e&&(r(),s({workflow:{...e,...o,updatedAt:new Date().toISOString()}}))},resetBuilder:()=>{s({workflow:null,selectedNodeId:null,selectedEdgeId:null,isDragging:!1,isConnecting:!1,connectionStart:null,history:[],historyIndex:-1,isSaving:!1,isExecuting:!1})}}));export{m as u};
